+++
toc = true
title = "行表达式"
weight = 1
+++

## 实现动机

配置的简化与一体化是行表达式所希望解决的两个主要问题。

在繁琐的数据分片规则配置中，随着数据节点的增多，大量的重复配置使得配置本身不易被维护。通过行表达式可以有效的简化数据节点配置工作量。

对于常见的分片算法，使用Java代码实现并不有助于配置的统一管理。通过行表达式书写分片算法，可以有效的将规则配置一同存放，更加易于浏览与存储。

## 使用方法

在配置中使用`${ expression }`或`$->{ expression }`即可。目前行表达式支持配置数据节点和配置分片算法两个部分。

## 语法说明

`${begin..end}`表示范围区间

`${[unit_1, unit_2, unit_x]}`表示枚举值

行表达式中如果出现连续多个`${ expression }`或`$->{ expression }`表达式，整个表达式最终的结果将会根据每个子表达式的结果进行笛卡尔组合。
如下的行表达式：

```groovy
${['online', 'offline']}_table_${1..3}
```

最终会解析为：

```
online_table_1, online_table_2, online_table_3, offline_table_1, offline_table_2, offline_table_3
```

### 配置数据节点

对于均匀分布的数据节点，如果数据结构如下：

```
db0
  ├── t_order_0 
  └── t_order_1 
db1
  ├── t_order_0 
  └── t_order_1
```

用行表达式可以简化为：

```
db${0..1}.t_order_${0..1}
```

或者

```
db$->{0..1}.t_order_$->{0..1}
```

对于自定义的数据节点，如果数据机构如下：

```
db0
  ├── t_order_0 
  └── t_order_1 
db1
  ├── t_order_2
  ├── t_order_3
  └── t_order_4
```

用行表达式可以简化为：

```
db0.t_order_${0..1},db1.t_order_${2..4}
```

或者

```
db0.t_order_$->{0..1},db1.t_order_$->{2..4}
```

### 配置分片算法

对于只有一个分片键的使用=和IN进行分片的SQL，可以使用行表达式代替Java类的配置。

Inline内部的表达式本质上是一段groovy代码。可以根据分片键进行计算的方式，返回相应的真实数据源或真实表名称。
例如，如果分为10个库，尾数为0的路由到后缀为0的数据源， 尾数为1的路由到后缀为1的数据源，以此类推，用于表示分片算法的行表达式为：

```groovy 
ds_${id % 10}
```

或者

```groovy 
ds_$->{id % 10}
```
