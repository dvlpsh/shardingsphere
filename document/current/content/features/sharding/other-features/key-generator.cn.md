+++
toc = true
title = "分布式主键"
weight = 2
+++

## 实现动机

传统数据库软件开发中，主键自动生成技术是基本需求。而各个数据库对于该需求也提供了相应的支持，比如MySQL的自增键，Oracle的自增序列等。
数据分片后，不同数据节点生成全局唯一主键是非常棘手的问题。同一个逻辑表内的不同实际表之间的自增键由于无法互相感知而产生重复主键。
虽然可通过约束自增主键初始值和步长的方式避免碰撞，但需引入额外的运维规则，使解决方案缺乏完整性和可扩展性。

目前有许多第三方解决方案可以完美解决这个问题，如UUID等依靠特定算法自生成不重复键，或者通过引入主键生成服务等。
但也正因为这种多样性导致了Sharding-Sphere如果强依赖于任何一种方案就会限制其自身的发展。

基于以上的原因，Sharding-Sphere最终采用以接口来实现对于生成主键的访问，而将底层具体的主键生成实现分离出来。

## 默认分布式主键生成器

Sharding-Sphere提供灵活的配置分布式主键生成策略方式。
在分片规则配置模块可配置每个表的主键生成策略，默认使用雪花算法（snowflake）生成64bit的长整型数据。

雪花算法是由Twitter公布的分布式主键生成算法，它能够保证不同进程主键的不重复性，以及相同进程主键的有序性。

在同一个进程中，它首先是通过时间位保证不重复，如果时间相同则是通过序列位保证。
同时由于时间位是单调递增的，且各个服务器如果大体做了时间同步，那么生成的主键在分布式环境可以认为是总体有序的，这就保证了对索引字段的插入的高效性。例如MySQL的Innodb存储引擎的主键。

使用雪花算法生成的主键，二进制表示形式包含4部分，从高位到低位分表为：1bit符号位、41bit时间戳位、10bit工作进程位以及12bit序列号位。

 - 符号位(1bit)

预留的符号位，恒为零。
 
 - 时间戳位(41bit)
 
41位的时间戳可以容纳的毫秒数是2的42次方减1，一年所使用的毫秒数是：365 * 24 * 60 * 60 * 1000。通过计算可知：

```java
(Math.pow(2, 42) -1) / (365 * 24 * 60 * 60 * 1000L);
```

结果约等于139.46年。Sharding-Sphere的雪花算法的时间纪元从2016年11月1日零点开始，可以使用到2156年，相信能满足绝大部分系统的要求。

 - 工作进程位(10bit)

该标志在Java进程内是唯一的，如果是分布式应用部署应保证每个工作进程的id是不同的。该值默认为0，可通过调用静态方法DefaultKeyGenerator.setWorkerId("xxxx")设置。

 - 序列号位(12bit)

该序列是用来在同一个毫秒内生成不同的ID。如果在这个毫秒内生成的数量超过4096(2的12次方)，那么生成器会等待到下个毫秒继续生成。

雪花算法主键的详细结构见下图。

![雪花算法](/img/sharding/snowflake.png)
